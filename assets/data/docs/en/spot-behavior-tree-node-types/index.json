{"hash":"d403c7d5b1034a330a113d4fce5b7deb98a519e1","data":{"doc":{"id":"777f667fcdf465bbd1e48e0719022e66","title":"Behavior Tree Node Types","contributors":["LoSk-p"],"translated":true,"headings":[],"subtitles":[{"depth":2,"value":"Node","anchor":"#node"},{"depth":2,"value":"Sequence","anchor":"#sequence"},{"depth":2,"value":"Selector","anchor":"#selector"},{"depth":2,"value":"Repeat","anchor":"#repeat"},{"depth":2,"value":"Retry","anchor":"#retry"},{"depth":2,"value":"ForDuration","anchor":"#forduration"},{"depth":2,"value":"SimpleParallel","anchor":"#simpleparallel"},{"depth":2,"value":"Condition","anchor":"#condition"},{"depth":2,"value":"BosdynRobotState","anchor":"#bosdynrobotstate"},{"depth":2,"value":"RemoteGrpc","anchor":"#remotegrpc"},{"depth":2,"value":"Sleep","anchor":"#sleep"},{"depth":2,"value":"Prompt","anchor":"#prompt"},{"depth":2,"value":"BosdynRobotCommand","anchor":"#bosdynrobotcommand"},{"depth":2,"value":"BosdynPowerRequest","anchor":"#bosdynpowerrequest"},{"depth":2,"value":"BosdynNavigateTo","anchor":"#bosdynnavigateto"},{"depth":2,"value":"BosdynGraphNavState","anchor":"#bosdyngraphnavstate"},{"depth":2,"value":"BosdynGraphNavLocalize","anchor":"#bosdyngraphnavlocalize"},{"depth":2,"value":"DefineBlackboard","anchor":"#defineblackboard"},{"depth":2,"value":"SetBlackboard","anchor":"#setblackboard"},{"depth":2,"value":"FormatBlackboard","anchor":"#formatblackboard"},{"depth":2,"value":"DateToBlackboard","anchor":"#datetoblackboard"}],"content":"\n## Node\n\nType `Node`:\n\nArguments:\n\n- `impl`, type: `google.protobuf.Any` or `node_reference`, type: `string` - implementation of this node or unique identifier of another node. If this is filled out, rather than the \"impl\", then the referenced node will be used in place of this one\n- `name`, type: `string` - human-readable name of this node\n- `user_data`, type: `UserData` - collection of user data associated with this node\n- `reference_id`, type: `string` - reference identifier of this node. Set iff another node references this one\n- `parameter_values`, type: `repeated KeyValue` - defines parameters, used by this node or its children. The \"key\" in KeyValue is the name of the parameter being defined. The value can be a constant or another parameter value\n- `overrides`, type: `repeated KeyValue` - overwrites a protobuf field in this node's implementation. The \"key\" in KeyValue is the name of the field to override. The value to write can be sourced from a constant, or a parameter value\n- `parameters`, type: `repeated VariableDeclaration` - declares parameters needed at compile time by this node, or children of this node. This is a way for a node to communicate what parameters its implementation and/or children require, without unpacking the entire subtree\n\nType `KeyValue`:\n\n- `key`, type: `string` \n- `value`, type: `Value`\n\nType `Value`:\n\n- `constant`, type: `ConstantValue`- a constant value\n- `runtime_var`, type: `VariableDeclaration` - look up a variable provided at run-time\n- `parameter`, type `VariableDeclaration` - look up a Node Parameter\n\nType `VariableDeclaration`:\n\n- `name`, type: `String` - name of the variable\n- `type`, type: `Type` - type that this variable is expected to have. Supported types: `TYPE_UNKNOWN`, `TYPE_FLOAT`, `TYPE_STRING`, `TYPE_INT`, `TYPE_BOOL`, `TYPE_MESSAGE`\n\n## Sequence\n\nSpecify a list of actions for the robot to perform.\n\nArguments:\n\n- `always_restart`, type: `bool` - forces the execution to always begin with the first child.  If false, and the Sequence ran last tick, it will continue with the node it was ticking.\n- `children`, type: `repeated Node` - list of all children to iterate through\n\n## Selector\n\nRun all children in order until a child succeeds.\n\nArguments:\n\n- `always_restart`, type: `bool` - forces the execution to always begin with the first child.  If false, and the Sequence ran last tick, it will continue with the node it was ticking.\n- `children`, type: `repeated Node` - list of all children to iterate through\n\n## Repeat\n\nLoop a subtree a certain number of times.\n\nArguments:\n\n- `max_starts`, type: `int32` - start the child node exactly this many times\n- `child`, type: `Node` - child to repeate max_starts times\n- `start_counter_state_name`, type: `string` - if set, the node will write the start index to the blackboard\n\n## Retry\n\nRetry a child node until it succeeds, or exceeds a number of attempts.\n\nArguments:\n\n- `max_attempts`, type: `int32` - only allow this many attempts\n- `child`, type: `Node` - child to retry up to max_attempts\n- `attempt_counter_state_name`, type: `string` - if set, the node will write the attempt index to the blackboard\n\n## ForDuration\n\nRun this child for a maximum amount of mission execution time. Will exit with child's status if the child finishes early, FAILURE if the child remains in RUNNING state for too long.\n\nArguments:\n\n- `duration`, type: `google.protobuf.Duration` - maximum duration of mission execution time\n- `child`, type: `Node` - child to execute for the duration\n\n## SimpleParallel\n\nRun two child nodes together, returning the primary child's result when it completes.\n\nArguments:\n\n- `primary`, type: `Node` - primary node, whose completion will end the execution of SimpleParallel\n- `secondary`, type: `Node` - secondary node, which will be ticked as long as the primary is still running\n\n## Condition\n\nChecks a simple comparison statement.\n\nArguments:\n\n- `lhs`, type: `Operand` - left-hand side of the comparison\n- `rhs`, type: `Operand` - right-hand side of the comparison\n- `operation`, type: `Compare` - comparison operator to compare lhs and rhs\n- `handle_staleness`, type: `HandleStaleness` - when comparing runtime values in the blackboard, some values might be \"stale\" (i.e too old). This defines how the comparator should behave when a read value is stale.\n\nType `Operand`:\n\n- `var`, type: `VariableDeclaration` - reference an existing variable\n- `const`, type: `ConstantValue` - use a constant value\n\nType `ConstantValue`:\n\n- Supported values: double float_value; string string_value; int64 int_value; bool bool_value; google.protobuf.Any msg_value;\n\nType `Compare`:\n\n- `COMPARE_UNKNOWN` - invalid, do not use\n- `COMPARE_EQ` - equal\n- `COMPARE_NE` - not equal\n- `COMPARE_LT` - less than\n- `COMPARE_GT` - greater than\n- `COMPARE_LE` - less than or equal\n- `COMPARE_GE` - greater than or equal\n\nType `HandleStaleness`:\n\n- `HANDLE_STALE_UNKNOWN` - acts like READ_ANYWAY for backwards compatibility\n- `HANDLE_STALE_READ_ANYWAY` - ignore how stale this data is\n- `HANDLE_STALE_RUN_UNTIL_FRESH` - return the RUNNING status until the data being read is not stale\n- `HANDLE_STALE_FAIL` - return FAILURE status if stale data is read\n\n## BosdynRobotState\n\nGet state from the robot.\n\nArguments:\n\n- `service_name`, type: `string` - name of the service to use (robot-state)\n- `host`, type: `string` - host machine the service is running on (localhost)\n- `child`, type: `Node` - child node. Children will have access to the state gathered by this node\n- `state_name`, type: `string` - name of the bosdyn.api.RobotState object in the blackboard. For example, if this is set to \"robot\", children can look up \"robot.power_state.motor_power_state\" in the blackboard\n\n## RemoteGrpc\n\nCall out to another system using the RemoteMission service.\n\nArguments:\n\n- `host`, type: `string` - host that is running the directory server. Usually, this is just the robot\n- `service_name`, type: `string`: name of the service in the directory\n- `timeout`, type: `float` - timeout of any single RPC. If the timeout is exceeded, the RPC will fail\n- `lease_resources`, type: `string` - resources that we will need leases on\n- `inputs`, type: `KeyValue` - the list of variables the remote host should receive\n\n## Sleep\n\nWhen started, begins a sleep timer for X seconds. Returns \"success\" after the timer elapses, \"running\" otherwise.\n\nArguments:\n\n- `seconds`, type: `float` - number of seconds to sleep for\n- `restart_after_stop`, type: `bool` - if this node is stopped, should it restart the timer?\n\n## Prompt\n\nPrompt the world at large to answer a question. This node represents a request for information from ANY listeners that may be out there.\n\nArguments:\n\n- `always_reprompt`, type: `bool` - should we always re-prompt when this node is started? If false, this node will only ever prompt if it is started and its question is unanswered. If true, this node will prompt whenever it is started.\n- `text`, type: `string` - the text of the question itself\n- `source`, type: `string` - the answer will be written into the state blackboard with this as the variable name\n- `options`, type: `repeated Option` - data about the options to choose from\n- `child`, type: `Node` - child node, run after the prompt has been responded to. Children will have access to the answer code provided by the response\n- `for_autonomous_processing`, type: `bool` - hint that Question posed by this Prompt is meant to be answered by some automated system\n\nType `Option`:\n\n- `text`, type: `string` - text associated with this option. Should be displayed to the user\n- `answer_code`, type: `int64` - numeric code corresponding to this option. Passed as part of the answer\n\n## BosdynRobotCommand\n\nExecute a RobotCommand. These nodes will \"succeed\" once a feedback response is received indicating success. Any commands that require an \"end time\" will have that information set based on the end time of the mission.\n\nArguments:\n\n- `service_name`, type: `string` - name of the service to use (robot-command)\n- `host`, type: `string` - host machine the directory is running on (localhost)\n- `command`, type: `RobotCommand` - the command to execute\n\n## BosdynPowerRequest\n\nMake a robot power request.\n\nArguments:\n\n- `service_name`, type: `string` - name of the service to use (power)\n- `host`, type: `string` - host machine the directory is running on (localhost)\n- `request`, type: `bosdyn.api.PowerCommandRequest.Request` - the request to make\n\n## BosdynNavigateTo\n\nTell the robot to navigate to a waypoint.\n\nArguments:\n\n- `service_name`, type: `string` - name of the service to use (graph-nav)\n- `host`, type: `string` - host machine the directory is running on (localhost)\n- `destination_waypoint_id`, type: `string` - ID of the waypoint to go to\n- `route_gen_params`, type: `bosdyn.api.graph_nav.RouteGenParams` - preferences on how to pick the route\n- `travel_params`, type: `bosdyn.api.graph_nav.TravelParams` - parameters that define how to traverse and end the route\n\n## BosdynGraphNavState\n\nGet GraphNav state from the robot and save it to the blackboard.\n\nArguments:\n\n- `service_name`, type: `string` - name of the service to use (graph-nav)\n- `host`, type: `string` - host machine the directory is running on (localhost)\n- `child`, type: `Node` - child node. Children will have access to the state gathered by this node\n- `state_name`, type: `string` - name of the bosdyn.api.GetLocalizationStateResponse object in the blackboard. For example, if this is set to \"nav\", children can look up \"nav.localization.waypoint_id\" in the blackboard to get the waypoint the robot is localized to\n- `waypoint_id`, type: `string` - id of the waypoint that we want the localization to be relative to. If this is empty, the localization will be relative to the waypoint that the robot is currently localized to\n\n## BosdynGraphNavLocalize\n\nTell GraphNav to re-localize the robot using a SetLocalizationRequest. This overrides whatever the current localization is. This can be useful to reinitialize the system at a known state.\n\nArguments:\n\n- `service_name`, type: `string` - name of the service to use (graph-nav)\n- `host`, type: `string` - host machine the directory is running on (localhost)\n- `localization_request`, type: `osdyn.api.graph_nav.SetLocalizationRequest` - if no localization_request is provided, the default options used are FIDUCIAL_INIT_NEAREST (the system will initialize to the nearest fiducial). Otherwise, the options inside the set_localization_request will be used\n\n## DefineBlackboard\n\nDefines new blackboard variables within the scope of the child. Shadows blackboard variables in the parent scope.\n\nArguments:\n\n- `blackboard_variables`, type: `repeated KeyValue` - the list of variables that should be defined for this subtree, with initial values\n- `child`, type: `Node` - the blackboard variables will only persist in the subtree defined by this child node. The child's tick() will be called on the child until it returns either SUCCESS or FAILURE\n\n## SetBlackboard\n\nSets existing blackboard variables within this scope to specific values, returning SUCCESS.\n\nArguments:\n\n- `blackboard_variables`, type: `repeated KeyValue` - the key of the KeyValue is the name of the blackboard variable. The value will be dereferenced and converted into a value type at runtime inside this node's tick function. For example, if the value is a runtime variable, that variable will be evaluated at tick time, and then stored into the blackboard. If the value is another blackboard variable, that blackboard variable's value will be copied into the variable specified by the key\n\n## FormatBlackboard\n\nSets a blackboard variable to a formatted string, reading from other blackboard vars.\n\nArguments:\n\n- `key`, type: `string` - the key of the variable that will be written\n- `format`, type: `string` - define a format string that will be used together with the blackboard to generate string value.  Values from the blackboard will replace the keys in braces {}. Example: \"telop-{date}\", where \"date\" is a blackboard variable. Example: \"{date}_loop_{loop_counter}\", where \"loop_counter\" is a blackboard variable from a Repeat\n\n## DateToBlackboard\n\nRecord a datetime string into the blackboard. Writes the date according to ISO8601 format.\n\nArguments:\n\n- `key`, type: `string` - the key of the variable that will be written\n"}},"context":{}}